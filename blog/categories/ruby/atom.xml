<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | 哥有石头]]></title>
  <link href="http://jicheng1014.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jicheng1014.github.io/"/>
  <updated>2015-04-18T18:33:44+08:00</updated>
  <id>http://jicheng1014.github.io/</id>
  <author>
    <name><![CDATA[Atpking]]></name>
    <email><![CDATA[atpking@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby的Proc.new 与Lambda 的区别]]></title>
    <link href="http://jicheng1014.github.io/blog/2015/04/18/differences-of-proc-dot-new-and-lambda-in-ruby/"/>
    <updated>2015-04-18T15:18:09+08:00</updated>
    <id>http://jicheng1014.github.io/blog/2015/04/18/differences-of-proc-dot-new-and-lambda-in-ruby</id>
    <content type="html"><![CDATA[<h2>Ruby的Proc.new 与Lambda 的区别</h2>

<h3>缘起，Block 与 Proc</h3>

<p>Block 在ruby 中会像空气一般的存在于大量的代码当中。块最开始是用来循环时候用的东西，但慢慢的，block变成了委托利器，贯穿于各种代码之间。</p>

<p>举个例子，我有一个数组1,2,3,4,5,6   我想得到这个数组的平方
在传统的程序里面，我们这样实现</p>

<pre><code class="javascript">var arr = [1,2,3,4,5,6];
var answer = []`

for(var i = 0; i&lt;arr.length;i++){
  answer[] = arr[i]**2;
}
</code></pre>

<p>如果在ruby中，我们即可使用块来完成</p>

<pre><code>answer = [1,2,3,4,5].map {|item| item**2}
</code></pre>

<p>这里的{|item| item**2} 就是一个Block。</p>

<p>当然之所以这里的ruby 代码简洁的原因是因为map本身隐藏了一些逻辑，实际上map由模块Emuneration 实现
其实通过上面的代码基本上可以看出，Block类似其他语言中的C#或者java中的委托、事件的实现。</p>

<p>我们来仿照着写一个Block的应用（自行实现map）</p>

<pre><code class="ruby">class MyArray &lt; Array

  def my_map
    for item in self
      p yield(item)
    end
  end
end

arr = MyArray.new
arr.push 1,3,5

arr.my_map do item
  item**2
end 

# 结果输出 
# 1
# 9
# 25
</code></pre>

<p>我们把目光还是集中在<code>{|item| item **2}</code> 中，这个代码是我们手敲上去的，那有没有方式将其放入变量里呢？
答案是   有，就是Proc对象   就是我们的Proc.new 和lambda，他们会返回Proc对象,记得在做参数的时候要加&amp;符号</p>

<pre><code class="ruby">class MyArray &lt; Array

  def my_map
    for item in self
      yield(item)
    end

  end

  def my_map_using_proc(&amp;proc)   # 定义的时候就需要表示这是个Proc 对象
    answer = self.class.new
    for item in self
      #p proc.class    输出为Proc 对象
      answer.push(proc.call(item))
    end
    return answer

  end
end



arr = MyArray.new
arr.push 1,3,5

my_proc = Proc.new do |i|
  i**2
end

my_lambda = lambda do |i|
  i**2
end

arr2 = arr.my_map_using_proc(&amp;my_proc)  # 使用的时候也要说明
p arr2

arr3 = arr.my_map_using_proc(&amp;my_lambda)
p arr3
</code></pre>

<p>Ruby 下的Proc.new 和Lambda 都是为了生成我们的Proc 而使用的指令，从大方向上来说，他们功能上非常相似，但从细节上来讲，他们又有一些不同点</p>

<p>相同点非常简单，他们都返回Proc对象，结构一样，那么不同点呢？</p>

<ol>
<li>Proc.new 的参数不需要严格匹配，但是lambda 需要严格匹配</li>
</ol>


<p>  比如这里的<code>func1 = Proc.new {|p,q| p p,q};func1.call("x")</code>， 则输出 <code>"x" nil</code>，但是换做lambda，就不行：</p>

<pre><code class="``">  2.2.0 :014 &gt; func2 = lambda {|p,q| p p,q};func2.call("x")
ArgumentError: wrong number of arguments (1 for 2)
  from (irb):14:in `block in irb_binding'
  from (irb):14:in `call'
  from (irb):14
  from /Users/atpking/.rvm/rubies/ruby-2.2.0/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<ol>
<li>Proc.new 如果里面出现了return，则代表的外部的return，而不是Proc自己的return,则是返回一个Proc对象，比如说</li>
</ol>


<pre><code class="``">  2.2.0 :035 &gt; def Hello
  2.2.0 :036?&gt;   p = Proc.new{return "inner proc"}
  2.2.0 :037?&gt;   p.call
  2.2.0 :038?&gt;   return "func return"
  2.2.0 :039?&gt;   end
  2.2.0 :041 &gt; Hello()
   =&gt; "inner proc"
</code></pre>

<p>注意此处，返回的是inner proc,
注意，如果直接在irb 里写p = Proc.new{return 1}<br/>
之后p.call 的化，是要报localJumpError的，因为此时irb 并没有结束,还没有return</p>

<pre><code class="``">  2.2.0 :061 &gt; def Hello2
  2.2.0 :062?&gt;   p = lambda{return "inner proc"}
  2.2.0 :063?&gt;   p.call
  2.2.0 :064?&gt;   return "func return"
  2.2.0 :065?&gt;   end
   =&gt; :Hello2
  2.2.0 :068 &gt; Hello2()
   =&gt; "func return"
</code></pre>

<p>此处是func return。</p>

<p>那么这些区别会带来什么变化呢？答案是，lambda 可以带参数的回传， 更加灵活了。比如下面的一个例子</p>

<pre><code>2.2.0 :087 &gt; def my_func(n)
2.2.0 :088?&gt;   b = lambda {|item| return item*n }
2.2.0 :089?&gt;   end
 =&gt; :my_func
2.2.0 :090 &gt; my_func(2).call 5
 =&gt; 10
2.2.0 :091 &gt; my_func(2).class
 =&gt; Proc
2.2.0 :092 &gt;
</code></pre>

<p>而proc，就会出现下列的问题</p>

<pre><code>2.2.0 :094 &gt; def my_func(n)
2.2.0 :095?&gt;   b = proc {|item| return item*n }
2.2.0 :096?&gt;   end
 =&gt; :my_func
2.2.0 :097 &gt; my_func(2).class
 =&gt; Proc
2.2.0 :098 &gt; my_func(2).call 5
LocalJumpError: unexpected return
  from (irb):95:in `block in my_func'
  from (irb):98:in `call'
  from (irb):98
  from /Users/atpking/.rvm/rubies/ruby-2.2.0/bin/irb:11:in `&lt;main&gt;'
2.2.0 :099 &gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[current_user永不进入model]]></title>
    <link href="http://jicheng1014.github.io/blog/2014/11/21/current-useryong-bu-jin-ru-model/"/>
    <updated>2014-11-21T11:03:57+08:00</updated>
    <id>http://jicheng1014.github.io/blog/2014/11/21/current-useryong-bu-jin-ru-model</id>
    <content type="html"><![CDATA[<p>上次写代码的时候用到了devise，自然也会用到比较常用的current_user
之后我写的时候有这样一个需求</p>

<blockquote><p>在用户新建、保存一个model 的时候，应该顺手保存这个model是由谁建立的</p></blockquote>

<p>我觉得这是一个典型的callback 应用，于是在before_validate 加入了
<code>self.user_id = current_user.id</code>
这个写法,但是很显然的，运行一下程序，没有通过</p>

<p>发现是current_user 没有被正确的读出来</p>

<p>看来current_user 这种东西model 是读不到的。本来想看能否做一些手脚，
但是后来我想了一下，这要是加入进去了，那Rspec该怎么写？</p>

<p>又想起了妈妈的教诲  model 只做model该做的事情。current_user 是页面级别登录后产生的产物，
跟模型自身是没有任何原因的，看来callback 这个策略是行不通了，最多写成validate 提醒自己</p>

<p>只有在controller 下进行验证了
<code>ruby
def create
    @dress = current_user.shop.dresses.build(params[:dress])
    @dress.currency = current_user.shop.currency
    if @dress.save
       .....
    else
       .....
    end
  end
</code></p>

<p>大概就是这样了</p>
]]></content>
  </entry>
  
</feed>
